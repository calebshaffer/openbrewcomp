# Tasks to setup the application

namespace :setup do
  desc 'Create session store'
  task :session_store do
    path = File.join(RAILS_ROOT, 'config', 'initializers', 'session_store.rb')
    File.open(path, 'w') do |f|
      f.write <<-"EOD"
# This file was generated by 'rake setup:session_store' and must not be
# visible to the public. Do not check it into a public repository.

# If you have a load-balancing cluster, you will need to use the same
# version of this file on each machine. And be sure to restart your
# server when you modify this file.

# Your secret key for verifying cookie session data integrity.
# If you change this key, all old sessions will become invalid!
# Make sure the secret is at least 30 characters and all random,
# no regular words, or you'll be exposed to dictionary attacks.
ActionController::Base.session = {
  :session_key => '_openbrewcomp_session',
  :secret      => '#{ActiveSupport::SecureRandom.hex(64)}'
}
      EOD
    end
  end

  desc 'Create site keys'
  task :site_keys do
    path = File.join(RAILS_ROOT, 'config', 'initializers', 'site_keys.rb')
    File.open(path, 'w') do |f|
      f.write <<-"EOD"
# This file was generated by 'rake setup:site_keys' and must not be
# visible to the public. Do not check it into a public repository.

# If you have a load-balancing cluster, you will need to use the same
# version of this file on each machine. And be sure to restart your
# server if you modify this file, but you will invalidate all your
# passwords if you do modify it.

# A Site key gives additional protection against a dictionary attack if your
# DB is ever compromised.  With no site key, we store
#   DB_password = hash(user_password, DB_user_salt)
# If your database were to be compromised you'd be vulnerable to a dictionary
# attack on all your stupid users' passwords.  With a site key, we store
#   DB_password = hash(user_password, DB_user_salt, Code_site_key)
# That means an attacker needs access to both your site's code *and* its
# database to mount an "offline dictionary attack.":http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/web-authentication.html
#
# It's probably of minor importance, but recommended by best practices: 'defense
# in depth'.  Needless to say, if you upload this to github or the youtubes or
# otherwise place it in public view you'll kinda defeat the point.  Your users'
# passwords are still secure, and the world won't end, but defense_in_depth -= 1.
#
# Please note: if you change this, all the passwords will be invalidated, so DO
# keep it someplace secure.  Use the random value given or type in the lyrics to
# your favorite Jay-Z song or something; any moderately long, unpredictable text.
REST_AUTH_SITE_KEY = '#{ActiveSupport::SecureRandom.hex(40)}'

# Repeated applications of the hash make brute force (even with a compromised
# database and site key) harder, and scale with Moore's law.
#
#   bq. "To squeeze the most security out of a limited-entropy password or
#   passphrase, we can use two techniques [salting and stretching]... that are
#   so simple and obvious that they should be used in every password system.
#   There is really no excuse not to use them." http://tinyurl.com/37lb73
#   Practical Security (Ferguson & Scheier) p350
#
# A modest 10 foldings (the default here) adds 3ms.  This makes brute forcing
# 10 times harder, while reducing an app that otherwise serves 100 reqs/s to
# 78 signin reqs/s, an app that does 10reqs/s to 9.7 reqs/s.
#
# More:
# * http://www.owasp.org/index.php/Hashing_Java
# * "An Illustrated Guide to Cryptographic Hashes":http://www.unixwiz.net/techtips/iguide-crypto-hashes.html
REST_AUTH_DIGEST_STRETCHES = 10
      EOD
    end
  end

  desc 'Get system settings'
  task :prompt_for_settings do
    $stdout.write <<-"EOD"

This setup procedure will guide you through configuration of the
OpenBrewComp system for your site.

When default values for responses are available, they will be shown
within brackets, [like this].  If the default value is acceptable,
you may simply hit #{bold 'return'}.

Let's get started.
    EOD

    $config = {}
    $config[:admin_name]         = get_admin_account
    $config[:admin_email]        = get_admin_email($config[:admin_name])
    $config[:admin_password]     = get_admin_password($config[:admin_name])
    $config[:account_mgmt_email] = get_account_mgmt_email($config[:admin_email])
    $config[:club_name]          = get_club_name
    $config[:competition_name]   = get_competition_name
    $config[:mcab]               = get_mcab
  end

  desc 'Write config files'
  task :write_config_files => "setup:prompt_for_settings" do
    puts "\nCreating config files ..."
    Rake::Task["setup:write_app_config"].invoke
    Rake::Task["setup:write_fixtures"].invoke
  end

  desc 'Write app config file'
  task :write_app_config => "setup:prompt_for_settings" do
    path = File.join(RAILS_ROOT, 'config', 'settings.yml')
    File.open(path, 'w') do |f|
      f.write <<-"EOD"
# This file was generated by 'rake setup'. Modify it as appropriate for your
# system, but heed the following.
#
# WARNING: If you change the name of the admin account after you have
# run 'rake db:bootstrap', you must change the name of the admin account
# in the users table with a raw SQL command like
#
#   UPDATE users SET login = 'new_login_name' WHERE login = '#{$config[:admin_name]}';
#
# via a database client (psql, mysql, etc.) program.
#
# A change to the competition name here has no effect on the competition
# name stored in the database. The value here is only used to (1) set the
# competition name in the page header and (2) set the sender's name for
# emails generated by the exception notifier.

common: &common_settings
  club_name: "#{$config[:club_name]}"
  competition_name: "#{$config[:competition_name]}"
  admin_name: "#{$config[:admin_name]}"
  account_mgmt_email: "#{$config[:account_mgmt_email]}"

development: &non_production_settings
  <<: *common_settings

test:
  <<: *non_production_settings

production:
  <<: *common_settings
      EOD
    end
  end

  desc 'Write fixture files'
  task :write_fixtures => [ "setup:write_app_config", :environment ] do
    path = File.join(RAILS_ROOT, 'db', 'fixtures', 'users.yml')
    File.open(path, 'w') do |f|
      salt = User.make_token
      f.write <<-"EOD"
# This file was auto-generated by 'rake setup'
admin:
  id: 1
  login: #{$config[:admin_name]}
  salt: #{salt}
  crypted_password: #{User.password_digest($config[:admin_password], salt)}
  name: Administrator
  email: #{$config[:admin_email]}
  enabled: true
  is_admin: true
  created_at: <%= Time.now.utc.to_s(:db) %>
      EOD
    end

    path = File.join(RAILS_ROOT, 'db', 'fixtures', 'clubs.yml')
    File.open(path, 'w') do |f|
      f.write <<-"EOD"
# This file was auto-generated by 'rake setup'
<%
   CLUB_NAMES = [
     # Add other club names here, order does not matter;
     # they will be displayed in alphabetical order.

     # Example entries, uncomment to activate (yeah, right):

     # "Another Club Name",
     # "Yet Another Homebrew Club (YAHC)",
     # "And so on ...",

     # Your own club members will be entering, right?
     "#{$config[:club_name]}"
   ]
%>
other:
  id: <%= Club.other.id %>
  name: <%= Club.other.name %>
independent:
  id: 1
  name: 'Independent'
<% CLUB_NAMES.each_with_index do |name, i| %>
club<%= i %>:
  id: <%= i + 2 %>
  name: <%= name %>
<% end %>
      EOD
    end

    path = File.join(RAILS_ROOT, 'db', 'fixtures', 'competition_data.yml')
    File.open(path, 'w') do |f|
    f.write <<-"EOD"
# This file was auto-generated by 'rake setup'
event_data:
  id: 1
  name: #{$config[:competition_name]}
  mcab: #{$config[:mcab].to_s}
      EOD
    end
  end

  desc 'Print summary info'
  task :finish_setup => "setup:write_config_files" do
    $stdout.write <<-"EOD"

Three config files, config/settings.yml, config/initializers/site_keys.rb,
and config/initializers/session_store.rb have been created.

WARNING: The session_store.rb and site_keys.rb files should not be
placed in a public repository. Please read and follow the comments
in the files.

You may wish to review the contents of these files before proceeding.
Several of the values specified in these files should not be changed
after the database is populated.

To complete the initial setup, run the following commands:

  rake db:create:all
  rake db:bootstrap

    EOD
  end

  desc 'Run the setup process'
  task :run => [ "setup:prompt_for_settings", "setup:write_config_files", "setup:finish_setup" ]

  ########

  begin
    require 'term/ansicolor'
    include Term::ANSIColor
  rescue Exception => e
    def bold(s) s end
  end

  def prompt(str, options={})
    $stdout.print str
    $stdout.flush
  end

  def validate_email(addr)
    return false if addr.blank?
    valid = /^[^@\s]+@([a-z0-9][-a-z0-9]*\.)+[a-z]{2,}$/i.match(addr)
    prompt "#{bold addr} is not a valid email address.\n" unless valid
    valid
  end

  def get_admin_account
    min_account_length = 4
    default_admin_name = 'admin'
    prompt "\nEnter the name of the primary admin account [#{default_admin_name}]: "
    admin_name = $stdin.gets.chomp
    admin_name.blank? ? default_admin_name : admin_name
  end

  def get_admin_email(name)
    email_accepted = false
    until email_accepted
      prompt "\nEnter the email address for #{bold name}: "
      email_accepted = validate_email(email = $stdin.gets.chomp)
    end
    email
  end

  def get_admin_password(name)
    begin
      require 'termios'
      $stdin.extend Termios
      echo_term = $stdin.tcgetattr
      noecho_term = echo_term.dup
      noecho_term.lflag &= ~Termios::ECHO
    rescue Exception => e
      $stderr.puts "WARNING: Terminal control not available, password will not be masked\nTo resolve, run '[sudo] gem install termios'\nPress Ctrl-C to exit"
    end

    begin
      $stdin.tcsetattr(Termios::TCSANOW, noecho_term) if noecho_term
      min_password_length = 6
      password_accepted = false
      until password_accepted
        prompt "\nEnter the password for #{bold name}: "
        password = $stdin.gets.chomp

        prompt "\nVerify the password for #{bold name}: "
        password_confirm = $stdin.gets.chomp

        if password != password_confirm
          prompt "\nThe passwords do not match, please try again.\n"
        elsif password.length < min_password_length
          prompt "\nThe password should be at least #{min_password_length} characters.\n"
        else
          password_accepted = true
        end
      end
    ensure
      $stdin.tcsetattr(Termios::TCSANOW, echo_term) if echo_term
      $stdout.print "\n"
    end

    password
  end

  def get_account_mgmt_email(default)
    email_accepted = false
    until email_accepted
      prompt "\nEnter the address for administrative emails [#{default}]: "
      email = $stdin.gets.chomp
      email = default if email.blank?
      email_accepted = validate_email(email)
    end
    email
  end

  def get_club_name
    while true
      prompt "\nEnter the name of your club: "
      name = $stdin.gets.chomp
      break unless name.blank?
    end
    name
  end

  def get_competition_name
    while true
      prompt "\nEnter the name of your competition: "
      name = $stdin.gets.chomp
      break unless name.blank?
    end
    name
  end

  def get_mcab
    while true
      prompt "\nIs your competition a MCAB QE (y/n)? "
      ans = $stdin.gets.chomp.downcase[0,1]
      break if /y|n/.match(ans)
    end
    ans == 'y'
  end

end

desc 'Create system config files'
task :setup => [ "setup:session_store", "setup:site_keys", "setup:run" ]

# Tasks to setup the application

namespace :setup do

  desc 'Create session store'
  task :session_store do
    path = File.join(RAILS_ROOT, 'config', 'initializers', 'session_store.rb')
    File.open(path, 'w') do |f|
      f.write <<-"EOD"
# This file was generated by 'rake setup:session_store' and must not be
# visible to the public.  Do not check it into a public repository.

# If you have a load-balancing cluster, you will need to use the same
# version of this file on each machine.  And be sure to restart your
# server when you modify this file.

# Your secret key for verifying cookie session data integrity.
# If you change this key, all old sessions will become invalid!
# Make sure the secret is at least 30 characters and all random,
# no regular words, or you'll be exposed to dictionary attacks.
ActionController::Base.session = {
  :session_key => '_openbrewcomp_session',
  :secret      => '#{ActiveSupport::SecureRandom.hex(64)}'
}
      EOD
    end
  end

end

desc 'Create system config files'
task :setup => :"setup:session_store" do
  $stdout.write <<-"EOD"

This setup procedure will guide you through configuration of the
Open Brew Comp system for your site.

When default values for responses are available, they will be shown
within brackets, [like this].  If the default value is acceptable,
you may simply hit #{bold 'return'}.

Let's get started.
  EOD

  config = {}
  config[:admin_name]         = get_admin_account
  config[:admin_email]        = get_admin_email(config[:admin_name])
  config[:admin_password]     = get_admin_password(config[:admin_name])
  config[:account_mgmt_email] = get_account_mgmt_email(config[:admin_email])
  config[:club_name]          = get_club_name
  config[:competition_name]   = get_competition_name
  config[:mcab]               = get_mcab

  write_config(config)

  $stdout.write <<-"EOD"

Three config files, config/settings.yml, config/db_init.yml,
and config/initializers/site_keys.rb have been created.

After initializing your database(s), by running #{bold 'rake db:migrate'},
you should delete config/db_init.yml.

Please read the comments in config/initializers/site_keys.rb
and follow the suggestions in that file.

  EOD
end

begin
  require 'term/ansicolor'
  include Term::ANSIColor
rescue
  def bold(s) s end
end

def prompt(str, options={})
  $stdout.print str
  $stdout.flush
end

def write_config(settings)
  path = File.join(RAILS_ROOT, 'config', 'settings.yml')
  File.open(path, 'w') do |f|
    f.write <<-"EOD"
# This is config/settings.yml which was generated by 'rake setup'
# Modify it as appropriate for your system.

# WARNING: If you change the name of the admin account after you
# have performed the initial database migration, you must change
# the name of the admin account in the users table using a database
# client application.

common: &common_settings
  club_name: "#{settings[:club_name]}"
  competition_name: "#{settings[:competition_name]}"
  admin_name: "#{settings[:admin_name]}"
  account_mgmt_email: "#{settings[:account_mgmt_email]}"
  forgery_protect_key: "#{ActiveSupport::SecureRandom.hex(32)}"

development: &non_production_settings
  <<: *common_settings

test:
  <<: *non_production_settings

production:
  <<: *common_settings
    EOD
  end

  path = File.join(RAILS_ROOT, 'config', 'db_init.yml')
  File.open(path, 'w') do |f|
    f.write <<-"EOD"
# This is config/db_init.yml which was generated by 'rake setup'
# It is only used by 'rake db:migrate' so, although you can modify
# it as appropriate for your system, you must do so before you
# perform the initial database migration.
#
# WARNING: This file should not be visible to the public.
# Do not check it into a public repository like github.

common: &common_settings
  admin_email: "#{settings[:admin_email]}"
  admin_password: "#{settings[:admin_password]}"
  mcab: #{settings[:mcab].to_s}

development:
  <<: *common_settings

test:
  <<: *common_settings

production:
  <<: *common_settings
    EOD
  end

  path = File.join(RAILS_ROOT, 'config', 'initializers', 'site_keys.rb')
  File.open(path, 'w') do |f|
    f.write <<-"EOD"
# This is config/initializers/site_key.rb which was generated by 'rake setup'
#
# A Site key gives additional protection against a dictionary attack if your
# DB is ever compromised.  With no site key, we store
#   DB_password = hash(user_password, DB_user_salt)
# If your database were to be compromised you'd be vulnerable to a dictionary
# attack on all your stupid users' passwords.  With a site key, we store
#   DB_password = hash(user_password, DB_user_salt, Code_site_key)
# That means an attacker needs access to both your site's code *and* its
# database to mount an "offline dictionary attack.":http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/web-authentication.html
#
# It's probably of minor importance, but recommended by best practices: 'defense
# in depth'.  Needless to say, if you upload this to github or the youtubes or
# otherwise place it in public view you'll kinda defeat the point.  Your users'
# passwords are still secure, and the world won't end, but defense_in_depth -= 1.
#
# Please note: if you change this, all the passwords will be invalidated, so DO
# keep it someplace secure.  Use the random value given or type in the lyrics to
# your favorite Jay-Z song or something; any moderately long, unpredictable text.
REST_AUTH_SITE_KEY = '#{ActiveSupport::SecureRandom.hex(40)}'

# Repeated applications of the hash make brute force (even with a compromised
# database and site key) harder, and scale with Moore's law.
#
#   bq. "To squeeze the most security out of a limited-entropy password or
#   passphrase, we can use two techniques [salting and stretching]... that are
#   so simple and obvious that they should be used in every password system.
#   There is really no excuse not to use them." http://tinyurl.com/37lb73
#   Practical Security (Ferguson & Scheier) p350
#
# A modest 10 foldings (the default here) adds 3ms.  This makes brute forcing
# 10 times harder, while reducing an app that otherwise serves 100 reqs/s to
# 78 signin reqs/s, an app that does 10reqs/s to 9.7 reqs/s.
#
# More:
# * http://www.owasp.org/index.php/Hashing_Java
# * "An Illustrated Guide to Cryptographic Hashes":http://www.unixwiz.net/techtips/iguide-crypto-hashes.html
REST_AUTH_DIGEST_STRETCHES = 10
    EOD
  end

end

def validate_email(addr)
  return false if addr.blank?
  valid = /^[^@\s]+@([a-z0-9][-a-z0-9]*\.)+[a-z]{2,}$/i.match(addr)
  prompt "#{bold addr} is not a valid email address.\n" unless valid
  valid
end

def get_admin_account
  min_account_length = 4
  default_admin_name = 'admin'
  prompt "\nEnter the name of the primary admin account [#{default_admin_name}]: "
  admin_name = $stdin.gets.chomp
  admin_name.blank? ? default_admin_name : admin_name
end

def get_admin_email(name)
  email_accepted = false
  until email_accepted
    prompt "\nEnter the email address for #{bold name}: "
    email_accepted = validate_email(email = $stdin.gets.chomp)
  end
  email
end

def get_admin_password(name)
  begin
    require 'termios'
    $stdin.extend Termios
    echo_term = $stdin.tcgetattr
    noecho_term = echo_term.dup
    noecho_term.lflag &= ~Termios::ECHO
  rescue
    $stderr.puts 'WARNING: Terminal control not available'
  end

  begin
    $stdin.tcsetattr(Termios::TCSANOW, noecho_term) if noecho_term
    min_password_length = 6
    password_accepted = false
    until password_accepted
      prompt "\nEnter the password for #{bold name}: "
      password = $stdin.gets.chomp

      prompt "\nVerify the password for #{bold name}: "
      password_confirm = $stdin.gets.chomp

      if password != password_confirm
        prompt "\nThe passwords do not match, please try again.\n"
      elsif password.length < min_password_length
        prompt "\nThe password should be at least #{min_password_length} characters.\n"
      else
        password_accepted = true
      end
    end
  ensure
    $stdin.tcsetattr(Termios::TCSANOW, echo_term) if echo_term
    $stdout.print "\n"
  end

  password
end

def get_account_mgmt_email(default)
  email_accepted = false
  until email_accepted
    prompt "\nEnter the address for administrative emails [#{default}]: "
    email = $stdin.gets.chomp
    email = default if email.blank?
    email_accepted = validate_email(email)
  end
  email
end

def get_club_name
  while true
    prompt "\nEnter the name of your club: "
    name = $stdin.gets.chomp
    break unless name.blank?
  end
  name
end

def get_competition_name
  while true
    prompt "\nEnter the name of your competition: "
    name = $stdin.gets.chomp
    break unless name.blank?
  end
  name
end

def get_mcab
  while true
    prompt "\nIs your competition a MCAB QE (y/n)? "
    ans = $stdin.gets.chomp.downcase[0,1]
    break if /y|n/.match(ans)
  end
  ans == 'y'
end

